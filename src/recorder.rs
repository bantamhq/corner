use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};
use std::fs;
use std::io;
use std::path::Path;
use std::time::{Duration, Instant};

#[derive(Clone, PartialEq)]
enum TapeCommand {
    Type(String),
    Key { name: String, count: u32 },
    Sleep(Duration),
}

pub struct Recorder {
    events: Vec<(Duration, KeyEvent)>,
    start: Instant,
    name: String,
}

impl Recorder {
    pub fn new(name: impl Into<String>) -> Self {
        Self {
            events: Vec::new(),
            start: Instant::now(),
            name: name.into(),
        }
    }

    pub fn record(&mut self, key: KeyEvent) {
        let elapsed = self.start.elapsed();
        self.events.push((elapsed, key));
    }

    pub fn save(&self) -> io::Result<()> {
        let output_dir = Path::new("docs/examples/tapes");
        fs::create_dir_all(output_dir)?;

        let output_path = output_dir.join(format!("{}.tape", self.name));
        let template = load_template()?;
        let recorded = generate_tape(&self.events);

        let tape = format!("Output ../{}.gif\n\n{}\n{}", self.name, template, recorded);

        fs::write(&output_path, &tape)?;
        eprintln!(
            "\nSaved {} events to {}",
            self.events.len(),
            output_path.display()
        );
        Ok(())
    }
}

fn load_template() -> io::Result<String> {
    let template_path = Path::new("docs/examples/src/tape_template.tape");
    fs::read_to_string(template_path)
}

fn generate_tape(events: &[(Duration, KeyEvent)]) -> String {
    let filtered: Vec<_> = events
        .iter()
        .filter(|(_, key)| !is_quit_key(key))
        .cloned()
        .collect();

    let mut commands = events_to_commands(&filtered);
    commands = collapse_repeats(commands);
    commands.push(TapeCommand::Sleep(Duration::from_millis(1500)));

    format_commands(&commands)
}

fn is_quit_key(key: &KeyEvent) -> bool {
    matches!(key.code, KeyCode::Char('q' | 'Q')) && key.modifiers.contains(KeyModifiers::CONTROL)
}

fn events_to_commands(events: &[(Duration, KeyEvent)]) -> Vec<TapeCommand> {
    let mut commands = Vec::new();
    let mut pending_chars = String::new();
    let mut last_time = Duration::ZERO;

    for (i, (time, key)) in events.iter().enumerate() {
        let gap = time.saturating_sub(last_time);

        let is_plain_char = matches!(key.code, KeyCode::Char(_))
            && !key
                .modifiers
                .intersects(KeyModifiers::CONTROL | KeyModifiers::ALT);

        if !pending_chars.is_empty() && (!is_plain_char || gap > Duration::from_millis(500)) {
            commands.push(TapeCommand::Type(std::mem::take(&mut pending_chars)));
            if gap > Duration::from_millis(100) {
                commands.push(TapeCommand::Sleep(gap));
            }
        } else if pending_chars.is_empty() && gap > Duration::from_millis(100) && i > 0 {
            commands.push(TapeCommand::Sleep(gap));
        }

        match key.code {
            KeyCode::Char(c)
                if !key
                    .modifiers
                    .intersects(KeyModifiers::CONTROL | KeyModifiers::ALT) =>
            {
                pending_chars.push(c);
            }
            KeyCode::Char(c) => {
                commands.push(TapeCommand::Key {
                    name: format_modified_key(c, key.modifiers),
                    count: 1,
                });
            }
            code => {
                if let Some(name) = key_name(code) {
                    commands.push(TapeCommand::Key { name, count: 1 });
                }
            }
        }

        last_time = *time;
    }

    if !pending_chars.is_empty() {
        commands.push(TapeCommand::Type(pending_chars));
    }

    commands
}

fn collapse_repeats(commands: Vec<TapeCommand>) -> Vec<TapeCommand> {
    let mut result = Vec::new();

    for cmd in commands {
        match (&mut result.last_mut(), &cmd) {
            (
                Some(TapeCommand::Key { name: prev, count }),
                TapeCommand::Key {
                    name: curr,
                    count: 1,
                },
            ) if prev == curr => {
                *count += 1;
            }
            (Some(TapeCommand::Type(prev)), TapeCommand::Type(curr)) => {
                prev.push_str(curr);
            }
            (Some(TapeCommand::Sleep(prev)), TapeCommand::Sleep(curr)) => {
                *prev += *curr;
            }
            _ => result.push(cmd),
        }
    }

    result
}

fn format_commands(commands: &[TapeCommand]) -> String {
    let mut output = String::from("# Generated by corner --record\n\n");

    for cmd in commands {
        match cmd {
            TapeCommand::Type(s) => {
                let escaped = s.replace('"', r#"\""#);
                output.push_str(&format!("Type \"{escaped}\"\n"));
            }
            TapeCommand::Key { name, count } => {
                if *count > 1 {
                    output.push_str(&format!("{name} {count}\n"));
                } else {
                    output.push_str(&format!("{name}\n"));
                }
            }
            TapeCommand::Sleep(d) => {
                let ms = d.as_millis();
                if ms >= 1000 && ms % 1000 == 0 {
                    output.push_str(&format!("Sleep {}s\n", ms / 1000));
                } else {
                    output.push_str(&format!("Sleep {ms}ms\n"));
                }
            }
        }
    }

    output
}

fn key_name(code: KeyCode) -> Option<String> {
    let name = match code {
        KeyCode::Enter => "Enter",
        KeyCode::Tab => "Tab",
        KeyCode::BackTab => "Shift+Tab",
        KeyCode::Backspace => "Backspace",
        KeyCode::Esc => "Escape",
        KeyCode::Up => "Up",
        KeyCode::Down => "Down",
        KeyCode::Left => "Left",
        KeyCode::Right => "Right",
        KeyCode::Home => "Home",
        KeyCode::End => "End",
        KeyCode::PageUp => "PageUp",
        KeyCode::PageDown => "PageDown",
        KeyCode::Delete => "Delete",
        KeyCode::Insert => "Insert",
        KeyCode::F(n) => return Some(format!("F{n}")),
        KeyCode::Char(' ') => "Space",
        _ => return None,
    };
    Some(name.to_string())
}

fn format_modified_key(c: char, mods: KeyModifiers) -> String {
    let mut result = String::new();
    if mods.contains(KeyModifiers::CONTROL) {
        result.push_str("Ctrl+");
    }
    if mods.contains(KeyModifiers::ALT) {
        result.push_str("Alt+");
    }
    if mods.contains(KeyModifiers::SHIFT) {
        result.push_str("Shift+");
    }
    result.push(c.to_ascii_uppercase());
    result
}
